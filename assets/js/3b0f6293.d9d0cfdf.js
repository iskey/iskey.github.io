"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[1706],{3905:(n,t,e)=>{e.d(t,{Zo:()=>c,kt:()=>m});var i=e(7294);function r(n,t,e){return t in n?Object.defineProperty(n,t,{value:e,enumerable:!0,configurable:!0,writable:!0}):n[t]=e,n}function a(n,t){var e=Object.keys(n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(n);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(n,t).enumerable}))),e.push.apply(e,i)}return e}function s(n){for(var t=1;t<arguments.length;t++){var e=null!=arguments[t]?arguments[t]:{};t%2?a(Object(e),!0).forEach((function(t){r(n,t,e[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(e)):a(Object(e)).forEach((function(t){Object.defineProperty(n,t,Object.getOwnPropertyDescriptor(e,t))}))}return n}function d(n,t){if(null==n)return{};var e,i,r=function(n,t){if(null==n)return{};var e,i,r={},a=Object.keys(n);for(i=0;i<a.length;i++)e=a[i],t.indexOf(e)>=0||(r[e]=n[e]);return r}(n,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(n);for(i=0;i<a.length;i++)e=a[i],t.indexOf(e)>=0||Object.prototype.propertyIsEnumerable.call(n,e)&&(r[e]=n[e])}return r}var _=i.createContext({}),o=function(n){var t=i.useContext(_),e=t;return n&&(e="function"==typeof n?n(t):s(s({},t),n)),e},c=function(n){var t=o(n.components);return i.createElement(_.Provider,{value:t},n.children)},u={inlineCode:"code",wrapper:function(n){var t=n.children;return i.createElement(i.Fragment,{},t)}},l=i.forwardRef((function(n,t){var e=n.components,r=n.mdxType,a=n.originalType,_=n.parentName,c=d(n,["components","mdxType","originalType","parentName"]),l=o(e),m=r,f=l["".concat(_,".").concat(m)]||l[m]||u[m]||a;return e?i.createElement(f,s(s({ref:t},c),{},{components:e})):i.createElement(f,s({ref:t},c))}));function m(n,t){var e=arguments,r=t&&t.mdxType;if("string"==typeof n||r){var a=e.length,s=new Array(a);s[0]=l;var d={};for(var _ in t)hasOwnProperty.call(t,_)&&(d[_]=t[_]);d.originalType=n,d.mdxType="string"==typeof n?n:r,s[1]=d;for(var o=2;o<a;o++)s[o]=e[o];return i.createElement.apply(null,s)}return i.createElement.apply(null,e)}l.displayName="MDXCreateElement"},7546:(n,t,e)=>{e.r(t),e.d(t,{assets:()=>_,contentTitle:()=>s,default:()=>u,frontMatter:()=>a,metadata:()=>d,toc:()=>o});var i=e(7462),r=(e(7294),e(3905));const a={date:new Date("2016-04-20T22:36:00.000Z"),title:"\u8de8\u7f51\u6bb5\u4fee\u6539ip\u5730\u5740",categories:"socket",tags:["broadcast"]},s="\u8de8\u7f51\u6bb5\u4fee\u6539ip\u5730\u5740",d={unversionedId:"Linux/Tools/\u8de8\u7f51\u6bb5\u4fee\u6539ip\u5730\u5740",id:"Linux/Tools/\u8de8\u7f51\u6bb5\u4fee\u6539ip\u5730\u5740",title:"\u8de8\u7f51\u6bb5\u4fee\u6539ip\u5730\u5740",description:"\u6700\u8fd1\u6709\u4e2a\u9700\u6c42\uff0c\u9700\u8981\u5728windows\u5ba2\u6237\u7aef\u4e0b\uff0c\u8fdc\u7a0b\u4fee\u6539linux\u670d\u52a1\u5668\u7684ip\u5730\u5740\uff0c\u800c\u4e14\u8981\u6c42\u80fd\u591f\u8de8\u7f51\u6bb5\u4fee\u6539\uff0c\u9996\u5148\u76f8\u5f53\u7684\uff0c\u5f53\u7136\u662f\u7ec4\u64ad\u4e86\uff0c\u4e0b\u8fb9\u662f\u5b9e\u9645\u7684\u6e90\u7801\u3002",source:"@site/docs/Linux/Tools/\u8de8\u7f51\u6bb5\u4fee\u6539ip\u5730\u5740.md",sourceDirName:"Linux/Tools",slug:"/Linux/Tools/\u8de8\u7f51\u6bb5\u4fee\u6539ip\u5730\u5740",permalink:"/Linux/Tools/\u8de8\u7f51\u6bb5\u4fee\u6539ip\u5730\u5740",draft:!1,editUrl:"https://github.com/iskey/iskey.github.io/tree/main/docs/Linux/Tools/\u8de8\u7f51\u6bb5\u4fee\u6539ip\u5730\u5740.md",tags:[{label:"broadcast",permalink:"/tags/broadcast"}],version:"current",frontMatter:{date:"2016-04-20T22:36:00.000Z",title:"\u8de8\u7f51\u6bb5\u4fee\u6539ip\u5730\u5740",categories:"socket",tags:["broadcast"]},sidebar:"tutorialSidebar",previous:{title:"\u5982\u4f55\u4fee\u6539\u8fd0\u884c\u7a0b\u5e8f\u7684\u73af\u5883\u53d8\u91cf",permalink:"/Linux/Tools/\u5982\u4f55\u4fee\u6539\u8fd0\u884c\u7a0b\u5e8f\u7684\u73af\u5883\u53d8\u91cf"},next:{title:"\u8fdc\u7a0b\u6570\u636e\u540c\u6b65\u53ca\u64cd\u4f5c\u65b9\u6cd5",permalink:"/Linux/Tools/\u8fdc\u7a0b\u6570\u636e\u540c\u6b65\u53ca\u64cd\u4f5c\u65b9\u6cd5"}},_={},o=[{value:"Windows\u7aef",id:"windows\u7aef",level:2},{value:"Linux\u5ba2\u6237\u7aef",id:"linux\u5ba2\u6237\u7aef",level:2}],c={toc:o};function u(n){let{components:t,...e}=n;return(0,r.kt)("wrapper",(0,i.Z)({},c,e,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"\u8de8\u7f51\u6bb5\u4fee\u6539ip\u5730\u5740"},"\u8de8\u7f51\u6bb5\u4fee\u6539ip\u5730\u5740"),(0,r.kt)("p",null,"\u6700\u8fd1\u6709\u4e2a\u9700\u6c42\uff0c\u9700\u8981\u5728windows\u5ba2\u6237\u7aef\u4e0b\uff0c\u8fdc\u7a0b\u4fee\u6539linux\u670d\u52a1\u5668\u7684ip\u5730\u5740\uff0c\u800c\u4e14\u8981\u6c42\u80fd\u591f\u8de8\u7f51\u6bb5\u4fee\u6539\uff0c\u9996\u5148\u76f8\u5f53\u7684\uff0c\u5f53\u7136\u662f\u7ec4\u64ad\u4e86\uff0c\u4e0b\u8fb9\u662f\u5b9e\u9645\u7684\u6e90\u7801\u3002"),(0,r.kt)("h2",{id:"windows\u7aef"},"Windows\u7aef"),(0,r.kt)("p",null,"windows\u7aef\uff0c\u5728visual studio 2013\u4e0a\u7f16\u8bd1\u901a\u8fc7\uff0c\u4f7f\u7528\u65b9\u6cd5\uff0csend ","[ip][netmask]",",\u8be5\u7a0b\u5e8f\u4f1a\u5728windows\u4e0a\u7684\u6240\u6709\u7f51\u5361\u4e0a\u53d1\u9001\u7ec4\u64ad\u62a5\u6587\u3002"),(0,r.kt)("h2",{id:"linux\u5ba2\u6237\u7aef"},"Linux\u5ba2\u6237\u7aef"),(0,r.kt)("p",null,"\u4f7f\u7528\u65b9\u6cd5recv  ","[eth]","."),(0,r.kt)("p",null,"recv.c"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},'    #include <stdlib.h>  \n    #include <sys/types.h>  \n    #include <sys/socket.h>  \n    #include <netinet/in.h>  \n    #include <arpa/inet.h>  \n    #include <time.h>  \n    #include <string.h>  \n    #include <stdio.h>  \n    #include <unistd.h>  \n    \n    #define MAX_LEN  1024    /* maximum string size to send */\n    #define MIN_PORT 1024    /* minimum port allowed */\n    #define MAX_PORT 65535   /* maximum port allowed */\n    \n    #define HELLO_PORT 12345\n    #define HELLO_GROUP "225.0.0.37"\n    #define MSGBUFSIZE 256  \n    #define RAW_DATA_LEN 250\n    #define CMD_HEAD 0x57579090\n    #define CMD_MAX_SIZE 250\n    \n    \n    typedef struct _BROADCAST_CMD_{\n        uint32_t    head;\n        uint8_t     cmd;\n        uint16_t    data_len;\n        uint8_t     raw_data[RAW_DATA_LEN];\n        uint16_t    crc;\n    }BROADCAST_CMD;\n    \n    enum{\n        CMD_SET_IP = 0,\n        CMD_SET_NETMASK,\n        CMD_SET_IP_NETMASK,\n    };\n    \n    struct __IP_MASK__{\n        uint32_t ip;\n        uint32_t netmask;\n    };\n    \n    #define INVERT_TO_BIG_ENDIAN16(val) (((uint16_t)val& (uint16_t)0xff00) >>8  | \\\n                                            ((uint16_t)val& (uint16_t)0x00ff)<< 8)\n    \n    #define INVERT_TO_BIG_ENDIAIN32(val) (((uint32_t)val& (uint32_t)0xff000000)>> 24        | \\\n                                            ((uint32_t)val& (uint32_t)0x00ff0000)>> 8   | \\\n                                            ((uint32_t)val& (uint32_t)0x0000ff00)<< 8   | \\\n                                            ((uint32_t)val& (uint32_t)0x000000ff)<< 24)\n    \n    #define INVERT_TO_BIG_ENDIAN64(val) (((uint64_t) (val) & (uint64_t)(0x00000000000000ffU)) << 56) | \\\n                                            (((uint64_t)(val)& (uint64_t)(0x000000000000ff00U)) << 40) | \\\n                                            (((uint64_t)(val)& (uint64_t)(0x0000000000ff0000U)) << 24) | \\\n                                            (((uint64_t)(val)& (uint64_t)(0x00000000ff000000U)) << 8) | \\\n                                            (((uint64_t)(val)& (uint64_t)(0x000000ff00000000U)) >> 8) | \\\n                                            (((uint64_t)(val)& (uint64_t)(0x0000ff0000000000U)) >> 24) | \\\n                                            (((uint64_t)(val)& (uint64_t)(0x00ff000000000000U)) >> 40) | \\\n                                            (((uint64_t)(val)& (uint64_t)(0xff00000000000000U)) >> 56)))\n    \n    \n    #define TO_NET16(val) INVERT_TO_BIG_ENDIAN16(val)\n    #define TO_NET32(val) INVERT_TO_BIG_ENDIAIN32(val)\n    #define TO_NET64(val) INVERT_TO_BIG_ENDIAN64(val)\n    \n    int isBigEndian()\n    {\n        union MyUnion\n        {\n            uint8_t a[2];\n            uint16_t b;\n        };\n    \n        union MyUnion test;\n        test.b = 1;\n        return test.a[0];\n    }\n    \n    int main(int argc, char *argv[])  \n    {  \n        struct sockaddr_in addr;  \n        int fd, nbytes,addrlen;  \n        struct ip_mreq mreq;  \n        char msgbuf[MSGBUFSIZE];  \n        char str_cmd[CMD_MAX_SIZE];\n        char ip[50];\n        char netmask[50];\n    \n        u_int yes=1; /*** MODIFICATION TO ORIGINAL */  \n    \n        if(argc!=2){\n            printf("Usage: %s [eth_name]\\n", argv[0]);\n            return 0;\n        }\n        \n        snprintf(str_cmd, CMD_MAX_SIZE, "route add -net 0.0.0.0 %s", argv[1]);\n        system(str_cmd);\n        \n        /* create what looks like an ordinary UDP socket */  \n        if ((fd=socket(AF_INET,SOCK_DGRAM,0)) < 0)   \n        {  \n            perror("socket");  \n            exit(1);  \n        }  \n    \n        /**** MODIFICATION TO ORIGINAL */  \n        /* allow multiple sockets to use the same PORT number */  \n        if (setsockopt(fd,SOL_SOCKET,SO_REUSEADDR,&yes,sizeof(yes)) < 0)   \n        {  \n            perror("Reusing ADDR failed");  \n            exit(1);  \n        }  \n        /*** END OF MODIFICATION TO ORIGINAL */  \n    \n        /* set up destination address */  \n        memset(&addr,0,sizeof(addr));  \n        addr.sin_family=AF_INET;  \n        addr.sin_addr.s_addr=htonl(INADDR_ANY); /* N.B.: differs from sender */  \n        addr.sin_port=htons(HELLO_PORT);  \n    \n        /* bind to receive address */  \n        if (bind(fd,(struct sockaddr *) &addr,sizeof(addr)) < 0)  \n        {  \n            perror("bind");  \n            exit(1);  \n        }  \n    \n        /* use setsockopt() to request that the kernel join a multicast group */  \n        mreq.imr_multiaddr.s_addr=inet_addr(HELLO_GROUP);  \n        mreq.imr_interface.s_addr=htonl(INADDR_ANY);  \n        if (setsockopt(fd,IPPROTO_IP,IP_ADD_MEMBERSHIP,&mreq,sizeof(mreq)) < 0)   \n        {  \n            perror("setsockopt");  \n            exit(1);  \n        }  \n    \n        /* now just enter a read-print loop */  \n        while (1)   \n        {  \n            addrlen=sizeof(addr);  \n            if ((nbytes=recvfrom(fd,msgbuf,MSGBUFSIZE,0, (struct sockaddr *) &addr,(socklen_t*)&addrlen)) < 0)   \n            {  \n                perror("recvfrom");  \n                exit(1);  \n            }\n    \n            BROADCAST_CMD cmd, *p_cmd = (BROADCAST_CMD *)msgbuf;\n            struct __IP_MASK__ ip_mask, *p_ip_mask=  (struct __IP_MASK__*)(p_cmd->raw_data);\n    \n            ip_mask.ip = p_ip_mask->ip;\n            ip_mask.netmask = p_ip_mask->netmask;\n            if (isBigEndian()){\n                cmd.head = p_cmd->head;\n                cmd.cmd = p_cmd->cmd;\n                cmd.data_len = p_cmd->data_len;\n            }\n            else\n            {\n                cmd.head = TO_NET32(p_cmd->head);\n                cmd.cmd = p_cmd->cmd;\n                cmd.data_len = TO_NET16(p_cmd->data_len);\n            }\n    \n            if (cmd.head == CMD_HEAD){\n                printf("cmd head is 0x%08x.\\n", cmd.head);\n                printf("cmd.cmd is 0x%02x\\n", cmd.cmd);\n                snprintf(ip, sizeof(ip), "%s", (char*)(inet_ntoa(*(struct in_addr*)&ip_mask.ip)));\n                snprintf(netmask, sizeof(netmask), "%s", (char*)(inet_ntoa(*(struct in_addr*)&ip_mask.netmask)));\n                printf("ip is %s.\\n", ip);\n                printf("netmask is %s.\\n", netmask);\n            }\n    \n            snprintf(str_cmd, CMD_MAX_SIZE, "ifconfig %s %s netmask %s", argv[1], ip, netmask);\n            printf("cmd is %s.\\n", str_cmd);\n            system(str_cmd);\n        }  \n    \n        return 0;  \n    }  \n')),(0,r.kt)("p",null,"send.c"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},'    #include <sys/types.h>   /* for type definitions */\n    #include <winsock2.h>    /* for win socket API calls */\n    #include <ws2tcpip.h>    /* for win socket structs */\n    #include <stdio.h>       /* for printf() */\n    #include <stdlib.h>      /* for atoi() */\n    #include <string.h>      /* for strlen() */\n    \n    #include "inttypes.h"\n    #include "stdint.h"\n    \n    #define MAX_LEN  1024    /* maximum string size to send */\n    #define MIN_PORT 1024    /* minimum port allowed */\n    #define MAX_PORT 65535   /* maximum port allowed */\n    \n    #define HELLO_PORT 12345\n    #define HELLO_GROUP "225.0.0.37"\n    #define RAW_DATA_LEN 250\n    #define CMD_HEAD 0x57579090\n    \n    typedef struct _BROADCAST_CMD_{\n        uint32_t    head;\n        uint8_t     cmd;\n        uint16_t    data_len;\n        uint8_t     raw_data[RAW_DATA_LEN];\n        uint16_t    crc;\n    }BROADCAST_CMD;\n    \n    enum{\n        CMD_SET_IP = 0,\n        CMD_SET_NETMASK,\n        CMD_SET_IP_NETMASK,\n    };\n    \n    struct __IP_MASK__{\n        uint32_t ip;\n        uint32_t netmask;\n    };\n    \n    #define INVERT_TO_BIG_ENDIAN16(val) (((uint16_t)val& (uint16_t)0xff00) >>8  | \\\n        ((uint16_t)val& (uint16_t)0x00ff) << 8)\n    \n    #define INVERT_TO_BIG_ENDIAIN32(val) (((uint32_t)val& (uint32_t)0xff000000)>> 24        | \\\n        ((uint32_t)val& (uint32_t)0x00ff0000) >> 8 | \\\n        ((uint32_t)val& (uint32_t)0x0000ff00) << 8 | \\\n        ((uint32_t)val& (uint32_t)0x000000ff) << 24)\n    \n    #define INVERT_TO_BIG_ENDIAN64(val) (((uint64_t) (val) & (uint64_t)(0x00000000000000ffU)) << 56) | \\\n        (((uint64_t)(val)& (uint64_t)(0x000000000000ff00U)) << 40) | \\\n        (((uint64_t)(val)& (uint64_t)(0x0000000000ff0000U)) << 24) | \\\n        (((uint64_t)(val)& (uint64_t)(0x00000000ff000000U)) << 8) | \\\n        (((uint64_t)(val)& (uint64_t)(0x000000ff00000000U)) >> 8) | \\\n        (((uint64_t)(val)& (uint64_t)(0x0000ff0000000000U)) >> 24) | \\\n        (((uint64_t)(val)& (uint64_t)(0x00ff000000000000U)) >> 40) | \\\n        (((uint64_t)(val)& (uint64_t)(0xff00000000000000U)) >> 56)))\n    \n    #define TO_NET16(val) INVERT_TO_BIG_ENDIAN16(val)\n    #define TO_NET32(val) INVERT_TO_BIG_ENDIAIN32(val)\n    #define TO_NET64(val) INVERT_TO_BIG_ENDIAN64(val)\n    \n    int isBigEndian()\n    {\n        union MyUnion\n        {\n            uint8_t a[2];\n            uint16_t b;\n        };\n    \n        union MyUnion test;\n        test.b = 1;\n        return test.a[0];\n    }\n    \n    void usage(char *cmd)\n    {\n        printf("Usage:\\"%s [ip] [netmask]\\"\\n \\t e.g.: %s eth0 1.1.1.1 255.255.255.0\\n", cmd, cmd);\n    }\n    \n    #pragma comment(lib,"Ws2_32.lib") \n    \n    int send_ip_set_cmd(char* local_ip, char* remote_ip, char* remote_netmask)\n    {\n        int sock;                   /* socket descriptor */\n        struct sockaddr_in mc_addr; /* socket address structure */\n        //char* mc_addr_str;          /* multicast IP address */\n        //unsigned short mc_port;     /* multicast port */\n        unsigned char mc_ttl = 1;     /* time to live (hop count) */\n    \n        struct __IP_MASK__ ip_mask;\n        BROADCAST_CMD cmd;\n        \n        ip_mask.ip = inet_addr(remote_ip);\n        ip_mask.netmask = inet_addr(remote_netmask);\n       if (isBigEndian()){\n            cmd.head = CMD_HEAD;\n            cmd.cmd = CMD_SET_IP;\n            cmd.data_len = sizeof(struct __IP_MASK__);\n        }\n        else{\n            cmd.head = TO_NET32(CMD_HEAD);\n            cmd.cmd = CMD_SET_IP;\n            cmd.data_len = TO_NET16(sizeof(struct __IP_MASK__));\n        }\n        \n        memcpy(cmd.raw_data, &ip_mask, sizeof(ip_mask));\n        \n        \n        /* create a socket for sending to the multicast address */\n        if ((sock = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP)) < 0) {\n            perror("socket() failed");\n            exit(1);\n        }\n        \n        SOCKADDR_IN local_addr;\n        local_addr.sin_addr.S_un.S_addr=inet_addr(local_ip);\n        local_addr.sin_family=PF_INET;\n        local_addr.sin_port=htons(15501);\n        \n        if(-1== bind(sock, (SOCKADDR *)& local_addr, sizeof(SOCKADDR))){\n            printf("bind error.\\n");\n        }\n        \n        /* set the TTL (time to live/hop count) for the send */\n        if ((setsockopt(sock, IPPROTO_IP, IP_MULTICAST_TTL,\n            (const char*)&mc_ttl, sizeof(mc_ttl))) < 0) {\n            perror("setsockopt() failed");\n            exit(1);\n        }\n        \n        /* construct a multicast address structure */\n        memset(&mc_addr, 0, sizeof(mc_addr));\n        mc_addr.sin_family = AF_INET;\n        mc_addr.sin_addr.s_addr = inet_addr(HELLO_GROUP);\n        mc_addr.sin_port = htons(HELLO_PORT);\n        \n        \n        if (sendto(sock, (const char*)&cmd, sizeof(BROADCAST_CMD), 0, (struct sockaddr *) &mc_addr, sizeof(mc_addr)) < 0)\n        {\n            perror("sendto error.\\n");\n            exit(1);\n        }\n        \n    \n        printf("command send ok. ip addr is %s, netmask is %s\\n", remote_ip, remote_netmask);\n        \n        \n        closesocket(sock);\n    \n        return 0;\n    }\n    \n    int main(int argc, char *argv[])\n    {\n    \n        char szHostName[128];\n        WSADATA wsaData;            /* Windows socket DLL structure */\n    \n        /* validate number of arguments */\n        if (argc != 3) {\n            usage(argv[0]);\n            exit(1);\n        }\n    \n        printf("ip addr is %s, netmask is %s\\n", argv[1], argv[2]);\n        //mc_addr_str = argv[1];       /* arg 1: multicast IP address */\n        //mc_port = atoi(argv[2]); /* arg 2: multicast port number */\n    \n        /* validate the port range */\n        if ((HELLO_PORT < MIN_PORT) || (HELLO_PORT > MAX_PORT)) {\n            fprintf(stderr, "Invalid port number argument %d.\\n",\n                HELLO_PORT);\n            fprintf(stderr, "Valid range is between %d and %d.\\n",\n                MIN_PORT, MAX_PORT);\n            exit(1);\n        }\n        \n        /* Load Winsock 2.0 DLL */\n        if (WSAStartup(MAKEWORD(2, 0), &wsaData) != 0) {\n            fprintf(stderr, "WSAStartup() failed");\n            exit(1);\n        }\n    \n        if( gethostname(szHostName, 128) == 0 )\n        {\n            // Get host adresses\n            struct hostent * pHost; \n            int i;  \n            pHost = gethostbyname(szHostName); \n            for( i = 0; pHost!= NULL && pHost->h_addr_list[i]!= NULL; i++ )  \n            {\n                char * eth_name=inet_ntoa (*(struct in_addr *)pHost->h_addr_list[i]);\n                send_ip_set_cmd(eth_name, argv[1], argv[2]);\n            }\n        }\n    \n        WSACleanup();  /* Cleanup Winsock */\n        \n        return 0;\n    }\n')))}u.isMDXComponent=!0}}]);