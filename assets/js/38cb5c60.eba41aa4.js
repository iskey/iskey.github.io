"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[1942],{3905:(n,e,t)=>{t.d(e,{Zo:()=>a,kt:()=>u});var s=t(7294);function i(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function r(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(n);e&&(s=s.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,s)}return t}function l(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?r(Object(t),!0).forEach((function(e){i(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function _(n,e){if(null==n)return{};var t,s,i=function(n,e){if(null==n)return{};var t,s,i={},r=Object.keys(n);for(s=0;s<r.length;s++)t=r[s],e.indexOf(t)>=0||(i[t]=n[t]);return i}(n,e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);for(s=0;s<r.length;s++)t=r[s],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(i[t]=n[t])}return i}var c=s.createContext({}),d=function(n){var e=s.useContext(c),t=e;return n&&(t="function"==typeof n?n(e):l(l({},e),n)),t},a=function(n){var e=d(n.components);return s.createElement(c.Provider,{value:e},n.children)},o={inlineCode:"code",wrapper:function(n){var e=n.children;return s.createElement(s.Fragment,{},e)}},m=s.forwardRef((function(n,e){var t=n.components,i=n.mdxType,r=n.originalType,c=n.parentName,a=_(n,["components","mdxType","originalType","parentName"]),m=d(t),u=i,k=m["".concat(c,".").concat(u)]||m[u]||o[u]||r;return t?s.createElement(k,l(l({ref:e},a),{},{components:t})):s.createElement(k,l({ref:e},a))}));function u(n,e){var t=arguments,i=e&&e.mdxType;if("string"==typeof n||i){var r=t.length,l=new Array(r);l[0]=m;var _={};for(var c in e)hasOwnProperty.call(e,c)&&(_[c]=e[c]);_.originalType=n,_.mdxType="string"==typeof n?n:i,l[1]=_;for(var d=2;d<r;d++)l[d]=t[d];return s.createElement.apply(null,l)}return s.createElement.apply(null,t)}m.displayName="MDXCreateElement"},2492:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>l,default:()=>o,frontMatter:()=>r,metadata:()=>_,toc:()=>d});var s=t(7462),i=(t(7294),t(3905));const r={date:new Date("2016-04-07T13:12:00.000Z"),title:"Linux netlink\u901a\u8baf",categories:"kernel",tags:["kernel","netlink"]},l="Linux netlink\u901a\u8baf",_={unversionedId:"Linux/System/Linux netlink\u901a\u8baf",id:"Linux/System/Linux netlink\u901a\u8baf",title:"Linux netlink\u901a\u8baf",description:"\u6700\u8fd1\u9700\u8981\u4f7f\u7528netlink\u6765\u5b8c\u6210\u5185\u6838\u5c42\u548c\u7528\u6237\u5c42\u7684\u901a\u8baf\uff0c\u641c\u96c6\u4e86\u4e00\u4e2a\u7f51\u4e0a\u7684\u4f8b\u5b50\uff0c\u6682\u65f6\u6458\u6284\u5728\u6b64\uff0c\u5e76\u8ba1\u5212\u518d\u63a5\u4e0b\u6765\u518d\u8865\u5145\u4e00\u4e9b\u4e1c\u897f\uff1a",source:"@site/docs/Linux/System/Linux netlink\u901a\u8baf.md",sourceDirName:"Linux/System",slug:"/Linux/System/Linux netlink\u901a\u8baf",permalink:"/Linux/System/Linux netlink\u901a\u8baf",draft:!1,editUrl:"https://github.com/iskey/iskey.github.io/tree/main/docs/Linux/System/Linux netlink\u901a\u8baf.md",tags:[{label:"kernel",permalink:"/tags/kernel"},{label:"netlink",permalink:"/tags/netlink"}],version:"current",frontMatter:{date:"2016-04-07T13:12:00.000Z",title:"Linux netlink\u901a\u8baf",categories:"kernel",tags:["kernel","netlink"]},sidebar:"tutorialSidebar",previous:{title:"Iptables\u65f6\u95f4\u89c4\u5219\u5339\u914d",permalink:"/Linux/System/Iptables\u65f6\u95f4\u89c4\u5219\u5339\u914d"},next:{title:"Linux sysctl.conf \u4f18\u5316",permalink:"/Linux/System/Linux sysctl.conf \u4f18\u5316"}},c={},d=[{value:"\u5185\u6838\u7248\u672c",id:"\u5185\u6838\u7248\u672c",level:2},{value:"\u5185\u6838\u4ee3\u7801",id:"\u5185\u6838\u4ee3\u7801",level:3},{value:"\u7528\u6237\u7a7a\u95f4\u4ee3\u7801",id:"\u7528\u6237\u7a7a\u95f4\u4ee3\u7801",level:3},{value:"\u5185\u6838\u7ebf\u7a0b\u7248\u672c",id:"\u5185\u6838\u7ebf\u7a0b\u7248\u672c",level:2},{value:"\u5185\u6838\u4ee3\u7801",id:"\u5185\u6838\u4ee3\u7801-1",level:3},{value:"\u7528\u6237\u7a7a\u95f4\u4ee3\u7801",id:"\u7528\u6237\u7a7a\u95f4\u4ee3\u7801-1",level:3}],a={toc:d};function o(n){let{components:e,...t}=n;return(0,i.kt)("wrapper",(0,s.Z)({},a,t,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"linux-netlink\u901a\u8baf"},"Linux netlink\u901a\u8baf"),(0,i.kt)("p",null,"\u6700\u8fd1\u9700\u8981\u4f7f\u7528netlink\u6765\u5b8c\u6210\u5185\u6838\u5c42\u548c\u7528\u6237\u5c42\u7684\u901a\u8baf\uff0c\u641c\u96c6\u4e86\u4e00\u4e2a\u7f51\u4e0a\u7684\u4f8b\u5b50\uff0c\u6682\u65f6\u6458\u6284\u5728\u6b64\uff0c\u5e76\u8ba1\u5212\u518d\u63a5\u4e0b\u6765\u518d\u8865\u5145\u4e00\u4e9b\u4e1c\u897f\uff1a"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"ToDoList:")),(0,i.kt)("blockquote",null,(0,i.kt)("ul",{parentName:"blockquote",className:"contains-task-list"},(0,i.kt)("li",{parentName:"ul",className:"task-list-item"},(0,i.kt)("input",{parentName:"li",type:"checkbox",checked:!0,disabled:!0})," ","\u91cd\u5199netlink\u5185\u6838\u5b9e\u73b0\uff0c\u628a\u5904\u7406\u51fd\u6570\u653e\u5728\u5185\u6838\u7ebf\u7a0b\u91cc\u3002"),(0,i.kt)("li",{parentName:"ul",className:"task-list-item"},(0,i.kt)("input",{parentName:"li",type:"checkbox",checked:!1,disabled:!0})," ","\u4f7f\u7528net_namespace\u673a\u5236\u4e0b\u7684general netlink\u63a5\u53e3\u5199\u4e00\u4e2a\u5217\u5b50\u3002 "))),(0,i.kt)("h2",{id:"\u5185\u6838\u7248\u672c"},"\u5185\u6838\u7248\u672c"),(0,i.kt)("h3",{id:"\u5185\u6838\u4ee3\u7801"},"\u5185\u6838\u4ee3\u7801"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/timer.h>\n#include <linux/time.h>\n#include <linux/types.h>\n#include <net/sock.h>\n#include <net/netlink.h>\n\n#define NETLINK_TEST 25\n#define MAX_MSGSIZE 1024\nint stringlength(char *s);\nvoid sendnlmsg(int pid, char * message);\nint err;\nstruct sock *nl_sk = NULL;\n\nvoid sendnlmsg(int pid, char *message)\n{\n    struct sk_buff *skb_1;\n    struct nlmsghdr *nlh;\n    int len = NLMSG_SPACE(MAX_MSGSIZE);\n    int slen = 0;\n    if(!message || !nl_sk)\n    {\n        return ;\n    }\n    skb_1 = alloc_skb(len,GFP_KERNEL);\n    if(!skb_1)\n    {\n        printk(KERN_ERR "my_net_link:alloc_skb_1 error\\n");\n    }\n    slen = stringlength(message);\n    nlh = nlmsg_put(skb_1,0,0,0,MAX_MSGSIZE,0);\n\n    NETLINK_CB(skb_1).pid = 0;\n    NETLINK_CB(skb_1).dst_group = 0;\n\n    message[slen]= \'\\0\';\n    memcpy(NLMSG_DATA(nlh),message,slen+1);\n    printk("my_net_link:send message \'%s\'.\\n",(char *)NLMSG_DATA(nlh));\n\n    netlink_unicast(nl_sk,skb_1,pid,MSG_DONTWAIT);\n\n}\n\nint stringlength(char *s)\n{\n    int slen = 0;\n\n    for(; *s; s++){\n        slen++;\n    }\n\n    return slen;\n}\n\nvoid nl_data_ready(struct sk_buff *__skb)\n {\n    struct sk_buff *skb;\n    struct nlmsghdr *nlh;\n    char str[100];\n    struct completion cmpl;\n    int i=2;\n    skb = skb_get(__skb);\n    if(skb->len >= NLMSG_SPACE(0))\n    {\n        nlh = nlmsg_hdr(skb);\n\n        memcpy(str, NLMSG_DATA(nlh), sizeof(str));\n        printk("Message received from pid-%d:%s\\n",nlh->nlmsg_pid, str) ;\n        while(i--)\n        {\n            init_completion(&cmpl);\n            wait_for_completion_timeout(&cmpl,3 * HZ);\n            sendnlmsg(nlh->nlmsg_pid, "I am from kernel!");\n        }\n        kfree_skb(skb);\n    }\n\n }\n\n// Initialize netlink\nint netlink_init(void)\n{\n    nl_sk = netlink_kernel_create(&init_net, NETLINK_TEST, 1,\n                                 nl_data_ready, NULL, THIS_MODULE);\n\n    if(!nl_sk){\n        printk(KERN_ERR "my_net_link: create netlink socket error.\\n");\n        return 1;\n    }\n\n    printk("my_net_link_3: create netlink socket ok.\\n");\n\n    return 0;\n}\n\nstatic void netlink_exit(void)\n{\n    if(nl_sk != NULL){\n        sock_release(nl_sk->sk_socket);\n    }\n\n    printk("my_net_link: self module exited\\n");\n}\n\nmodule_init(netlink_init);\nmodule_exit(netlink_exit);\n\nMODULE_AUTHOR("frankzfz");\nMODULE_LICENSE("GPL");\n')),(0,i.kt)("h3",{id:"\u7528\u6237\u7a7a\u95f4\u4ee3\u7801"},"\u7528\u6237\u7a7a\u95f4\u4ee3\u7801"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'#include <sys/stat.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <string.h>\n#include <asm/types.h>\n#include <linux/netlink.h>\n#include <linux/socket.h>\n#include <errno.h>\n\n#define NETLINK_TEST 25\n#define MAX_PAYLOAD 1024 // maximum payload size\n\nint main(int argc, char* argv[])\n{\n    int state;\n    struct sockaddr_nl src_addr, dest_addr;\n    struct nlmsghdr *nlh = NULL;\n    struct iovec iov;\n    struct msghdr msg;\n    int sock_fd, retval;\n    int state_smg = 0;\n    \n    // Create a socket\n    sock_fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_TEST);\n    if(sock_fd == -1){\n        printf("error getting socket: %s", strerror(errno));\n        return -1;\n    }\n\n    // To prepare binding\n    memset(&msg,0,sizeof(msg));\n    memset(&src_addr, 0, sizeof(src_addr));\n    src_addr.nl_family = AF_NETLINK;\n    src_addr.nl_pid = getpid(); // self pid\n    src_addr.nl_groups = 0; // multi cast\n\n    retval = bind(sock_fd, (struct sockaddr*)&src_addr, sizeof(src_addr));\n    if(retval < 0){\n        printf("bind failed: %s", strerror(errno));\n        close(sock_fd);\n        return -1;\n    }\n\n    // To prepare recvmsg\n    nlh = (struct nlmsghdr *)malloc(NLMSG_SPACE(MAX_PAYLOAD));\n    if(!nlh){\n        printf("malloc nlmsghdr error!\\n");\n        close(sock_fd);\n        return -1;\n    }\n\n    memset(&dest_addr,0,sizeof(dest_addr));\n    dest_addr.nl_family = AF_NETLINK;\n    dest_addr.nl_pid = 0;\n    dest_addr.nl_groups = 0;\n\n    nlh->nlmsg_len = NLMSG_SPACE(MAX_PAYLOAD);\n    nlh->nlmsg_pid = getpid();\n    nlh->nlmsg_flags = 0;\n    strcpy(NLMSG_DATA(nlh),"Hello you iskey!");\n\n    iov.iov_base = (void *)nlh;\n    iov.iov_len = NLMSG_SPACE(MAX_PAYLOAD);\n//    iov.iov_len = nlh->nlmsg_len;\n\n    memset(&msg, 0, sizeof(msg));\n    msg.msg_name = (void *)&dest_addr;\n    msg.msg_namelen = sizeof(dest_addr);\n    msg.msg_iov = &iov;\n    msg.msg_iovlen = 1;\n\n    state_smg = sendmsg(sock_fd,&msg,0);\n    if(state_smg == -1)\n    {\n        printf("get error sendmsg = %s\\n",strerror(errno));\n    }\n    printf("send netlink message ok.\\n");\n\n    memset(nlh,0,NLMSG_SPACE(MAX_PAYLOAD));   \n    // Read message from kernel\n    while(1){\n        printf("In while recvmsg\\n");\n        state = recvmsg(sock_fd, &msg, 0);\n        if(state<0)\n        {\n            printf("state<1");\n        }\n        printf("Received message: %s\\n",(char *) NLMSG_DATA(nlh));\n    }\n\n    close(sock_fd);\n\n    return 0;\n}\n')),(0,i.kt)("h2",{id:"\u5185\u6838\u7ebf\u7a0b\u7248\u672c"},"\u5185\u6838\u7ebf\u7a0b\u7248\u672c"),(0,i.kt)("h3",{id:"\u5185\u6838\u4ee3\u7801-1"},"\u5185\u6838\u4ee3\u7801"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/timer.h>\n#include <linux/time.h>\n#include <linux/types.h>\n#include <net/sock.h>\n#include <net/netlink.h>\n#include "linux/list.h"\n#include <linux/kthread.h>\n\n#define NETLINK_TEST 25\n#define MAX_MSGSIZE 1024\nint stringlength(char *s);\nvoid sendnlmsg(int pid, char * message);\nint err;\nstruct sock *nl_sk = NULL;\n\nstruct _my_user_client_{\n    int pid;\n    unsigned char *msg;\n    struct list_head list; \n};\n\n//struct list_head client_head;\nLIST_HEAD(client_head);\nspinlock_t g_cli_list_lock= SPIN_LOCK_UNLOCKED;\nstruct task_struct *g_thread[10];\n\nint client_thread(void *data)\n{\n    struct list_head *plist, *list_n;\n    struct _my_user_client_ *my_client;\n    struct completion cmpl;\n    \n    init_completion(&cmpl);\n    daemonize("iskey_cli");\n\n    while(!kthread_should_stop())\n    //while(1)\n    {        \n        spin_lock(&g_cli_list_lock);\n        list_for_each_safe(plist, list_n, &client_head){\n            my_client= (struct _my_user_client_ *)list_entry(plist, struct _my_user_client_, list);\n            printk(KERN_ERR "kernel received msg:%s pid:%d.\\n", my_client->msg, my_client->pid);\n            sendnlmsg(my_client->pid, "I am from kernel!");\n            list_del(plist);\n            kfree(my_client);\n        }\n        spin_unlock(&g_cli_list_lock);\n        schedule_timeout_interruptible(msecs_to_jiffies(1));\n        wait_for_completion_timeout(&cmpl,3 * HZ);\n    }\n    printk(KERN_ERR "### thread end.\\n");\n\n    return 0;\n}\n\nvoid sendnlmsg(int pid, char *message)\n{\n    struct sk_buff *skb_1;\n    struct nlmsghdr *nlh;\n    int len = NLMSG_SPACE(MAX_MSGSIZE);\n    int slen = 0;\n    if(!message || !nl_sk)\n    {\n        return ;\n    }\n    skb_1 = alloc_skb(len,GFP_KERNEL);\n    if(!skb_1)\n    {\n        printk(KERN_ERR "my_net_link:alloc_skb_1 error\\n");\n    }\n    slen = stringlength(message);\n    nlh = nlmsg_put(skb_1,0,0,0,MAX_MSGSIZE,0);\n\n    NETLINK_CB(skb_1).pid = 0;\n    NETLINK_CB(skb_1).dst_group = 0;\n\n    message[slen]= \'\\0\';\n    memcpy(NLMSG_DATA(nlh),message,slen+1);\n    printk("my_net_link:send message \'%s\' pid:%d.\\n",(char *)NLMSG_DATA(nlh), pid);\n\n    netlink_unicast(nl_sk,skb_1,pid,MSG_DONTWAIT);\n\n}\n\nint stringlength(char *s)\n{\n    int slen = 0;\n\n    for(; *s; s++){\n        slen++;\n    }\n\n    return slen;\n}\n\nvoid nl_data_ready(struct sk_buff *__skb)\n {\n    struct sk_buff *skb;\n    struct nlmsghdr *nlh;\n    char str[100];\n    struct completion cmpl;\n    int i=2;\n    skb = skb_get(__skb);\n    if(skb->len >= NLMSG_SPACE(0))\n    {\n        nlh = nlmsg_hdr(skb);\n\n        memcpy(str, NLMSG_DATA(nlh), sizeof(str));\n\n        struct _my_user_client_ *client= kmalloc(sizeof(struct _my_user_client_), GFP_KERNEL);\n        unsigned char *t_data= kmalloc(sizeof(str),GFP_KERNEL);\n        memcpy(t_data, str, sizeof(str));\n        client->msg= t_data;\n        client->pid= nlh->nlmsg_pid;\n        spin_lock(&g_cli_list_lock);\n        list_add(&(client->list),&client_head);\n        spin_unlock(&g_cli_list_lock);\n        \n        printk("Message received from pid-%d:%s\\n",nlh->nlmsg_pid, str) ;\n//        while(i--)\n//        {\n//            init_completion(&cmpl);\n//            wait_for_completion_timeout(&cmpl,3 * HZ);\n//            sendnlmsg(nlh->nlmsg_pid, "I am from kernel!");\n//        }\n        kfree_skb(skb);\n    }\n\n }\n\n// Initialize netlink\nint netlink_init(void)\n{\n    nl_sk = netlink_kernel_create(&init_net, NETLINK_TEST, 1,\n                                 nl_data_ready, NULL, THIS_MODULE);\n\n    if(!nl_sk){\n        printk(KERN_ERR "my_net_link: create netlink socket error.\\n");\n        return 1;\n    }\n\n    int cpu=0;\n    \n//    for_each_present_cpu(cpu){\n        printk(KERN_ERR "cpu id is %d.\\n", cpu);\n        g_thread[cpu]= kthread_create(client_thread, &cpu, "netlink_thread%d", cpu);\n        if(IS_ERR(g_thread[cpu])){\n            printk(KERN_ERR "client_thread start error.\\n");\n            return 2;\n        }\n\n        printk(KERN_ERR "netlink_thread :%s\\n", g_thread[0]->comm);\n        \n        wake_up_process(g_thread[cpu]);\n//    }\n    \n    printk("my_net_link_3: create netlink socket ok.\\n");\n\n    return 0;\n}\n\nstatic void netlink_exit(void)\n{\n    if(nl_sk != NULL){\n        sock_release(nl_sk->sk_socket);\n    }\n\n    int cpu= 0;\n//    for_each_present_cpu(cpu){\n        kthread_stop(g_thread[cpu]);\n//    }\n    \n    printk("my_net_link: self module exited\\n");\n}\n\nmodule_init(netlink_init);\nmodule_exit(netlink_exit);\n\nMODULE_AUTHOR("frankzfz");\nMODULE_LICENSE("GPL");\n')),(0,i.kt)("h3",{id:"\u7528\u6237\u7a7a\u95f4\u4ee3\u7801-1"},"\u7528\u6237\u7a7a\u95f4\u4ee3\u7801"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'#include <sys/stat.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <string.h>\n#include <asm/types.h>\n#include <linux/netlink.h>\n#include <linux/socket.h>\n#include <errno.h>\n\n#define NETLINK_TEST 25\n#define MAX_PAYLOAD 1024 // maximum payload size\n\n\nint main(int argc, char* argv[])\n{\n    int state;\n    struct sockaddr_nl src_addr, dest_addr;\n    struct nlmsghdr *nlh = NULL;\n    struct iovec iov;\n    struct msghdr msg;\n    int sock_fd, retval;\n    int state_smg = 0;\n    \n    // Create a socket\n    sock_fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_TEST);\n    if(sock_fd == -1){\n        printf("error getting socket: %s", strerror(errno));\n        return -1;\n    }\n\n    // To prepare binding\n    memset(&msg,0,sizeof(msg));\n    memset(&src_addr, 0, sizeof(src_addr));\n    src_addr.nl_family = AF_NETLINK;\n    src_addr.nl_pid = getpid(); // self pid\n    src_addr.nl_groups = 0; // multi cast\n\n    retval = bind(sock_fd, (struct sockaddr*)&src_addr, sizeof(src_addr));\n    if(retval < 0){\n        printf("bind failed: %s", strerror(errno));\n        close(sock_fd);\n        return -1;\n    }\n\n    // To prepare recvmsg\n    nlh = (struct nlmsghdr *)malloc(NLMSG_SPACE(MAX_PAYLOAD));\n    if(!nlh){\n        printf("malloc nlmsghdr error!\\n");\n        close(sock_fd);\n        return -1;\n    }\n\n    memset(&dest_addr,0,sizeof(dest_addr));\n    dest_addr.nl_family = AF_NETLINK;\n    dest_addr.nl_pid = 0;\n    dest_addr.nl_groups = 0;\n\n    nlh->nlmsg_len = NLMSG_SPACE(MAX_PAYLOAD);\n    nlh->nlmsg_pid = getpid();\n    nlh->nlmsg_flags = 0;\n    strcpy(NLMSG_DATA(nlh),"Hello you iskey!");\n\n    iov.iov_base = (void *)nlh;\n    iov.iov_len = NLMSG_SPACE(MAX_PAYLOAD);\n//    iov.iov_len = nlh->nlmsg_len;\n\n    memset(&msg, 0, sizeof(msg));\n    msg.msg_name = (void *)&dest_addr;\n    msg.msg_namelen = sizeof(dest_addr);\n    msg.msg_iov = &iov;\n    msg.msg_iovlen = 1;\n\n    state_smg = sendmsg(sock_fd,&msg,0);\n    if(state_smg == -1)\n    {\n        printf("[user] get error sendmsg = %s\\n",strerror(errno));\n    }\n    printf("[user] send netlink message ok.\\n");\n\n    memset(nlh,0,NLMSG_SPACE(MAX_PAYLOAD));   \n    // Read message from kernel\n    //while(1){\n        printf("[user] receiving netlink msg...\\n");\n        state = recvmsg(sock_fd, &msg, 0);\n        if(state<0)\n        {\n            printf("[user] state<1");\n        }\n        printf("[user] Received message: %s\\n",(char *) NLMSG_DATA(nlh));\n    //}\n\n    close(sock_fd);\n\n    return 0;\n}\n')))}o.isMDXComponent=!0}}]);